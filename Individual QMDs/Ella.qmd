

## Data Upload + Libraries
```{r}
library(tidyverse)
library(tidymodels)
library(ggplot2)
library(knitr)
library(stats)
library(readr)
library(dplyr)
library(pROC)
library(caret)

data <- read.csv("data.csv")

```
## Logistic Models
### Odds for Benign vs Malignant
#### Making M and B into numeric values to make logistic work

### MEANS
```{r}
# M = 1, meaning malignant is closer to 1
data$diagnosis_num <- ifelse(data$diagnosis == "M", 1, 0)

logit_means <- glm(diagnosis_num ~ radius_mean + 
                     texture_mean + smoothness_mean
                   + compactness_mean + symmetry_mean,
                 data = data,
                 family = binomial)
tidy(logit_means)



```


```{r}
## RAW WITHOUT TEST TRAIN SPLIT
# predicted probability of M
data$pred_prob_means <- predict(logit_means, type = "response")

# predicted class using 0.5 threshold
data$pred_class_means <- ifelse(data$pred_prob_means > 0.5, "M", "B")
data$pred_class_means <- factor(data$pred_class_means, levels = c("B", "M"))

# confusion matrix
table(Predicted = data$pred_class_means, Actual = data$diagnosis)


```

```{r}
## ADDING TEST TRAIN SPLIT

set.seed(325)

train_idx <- sample(1:nrow(data), 0.7 * nrow(data))
train <- data[train_idx, ]
test  <- data[-train_idx, ]

train_acc <- mean(train$pred_class_means == train$diagnosis_num)
test_acc  <- mean(test$pred_class_means == test$diagnosis_num)

train_acc
test_acc


```
IDK what's going on here I'm ngl

```{r}

auc_train <- roc(train$diagnosis_num, train$pred_prob_means)$auc
auc_test  <- roc(test$diagnosis_num, test$pred_prob_means)$auc

auc_train
auc_test

roc_obj_means <- roc(test$diagnosis_num, test$pred_prob_means)

ggroc(roc_obj_means, size = 1.1, color = "blue") +
  ggtitle(paste("ROC Curve (AUC =", round(roc_obj_means$auc, 3), ")")) +
  theme_minimal(base_size = 14)

```

```{r}
# testing importance of each predictor

varImp(logit_means, scale = TRUE)
```
I added in area with radius just to see what would happen and it actual had more type 2 errors than when it was just radius which I found to be interesting. It also made radius MUCH less important which makes sense since they are related. Also, when I switched out area and radius, it increased type 2 error and decreased type 1 error. This could be interesting to see when looking at resources a hospital has.



### WORST


```{r}
logit_worst <- glm(diagnosis_num ~ radius_worst + 
                     texture_worst + smoothness_worst
                   + compactness_worst + symmetry_worst,
                 data = data,
                 family = binomial)
tidy(logit_worst)
```



```{r}
## RAW WITHOUT TEST TRAIN SPLIT
# predicted probability of M
data$pred_prob_worst <- predict(logit_worst, type = "response")

# predicted class using 0.5 threshold
data$pred_class_worst <- ifelse(data$pred_prob_worst > 0.5, "M", "B")
data$pred_class_worst <- factor(data$pred_class_worst, levels = c("B", "M"))

# confusion matrix
table(Predicted = data$pred_class_worst, Actual = data$diagnosis)


```

```{r}
## ADDING TEST TRAIN SPLIT

set.seed(325)

train_idx <- sample(1:nrow(data), 0.7 * nrow(data))
train <- data[train_idx, ]
test  <- data[-train_idx, ]

train_acc <- mean(train$pred_class_worst == train$diagnosis_num)
test_acc  <- mean(test$pred_class_worst == test$diagnosis_num)

train_acc
test_acc


```
IDK what's going on here I'm ngl

```{r}

auc_train <- roc(train$diagnosis_num, train$pred_prob_worst)$auc
auc_test  <- roc(test$diagnosis_num, test$pred_prob_worst)$auc

auc_train
auc_test

roc_obj_worst <- roc(test$diagnosis_num, test$pred_prob_worst)

ggroc(roc_obj_worst, size = 1.1, color = "blue") +
  ggtitle(paste("ROC Curve (AUC =", round(roc_obj_worst$auc, 3), ")")) +
  theme_minimal(base_size = 14)

```

```{r}
# testing importance of each predictor

varImp(logit_worst, scale = TRUE)
```
Radius seems to continue to be the best predictor; going to test radius worst vs radius mean

### DIFFERENCE BETWEEN MEANS AND WORST

```{r}
data$radius_mwdiff <- data$radius_mean - data$radius_worst
data$texture_mwdiff <- data$radius_mean - data$radius_worst
data$smoothness_mwdiff <- data$smoothness_mean - data$smoothness_worst
data$compactness_mwdiff <- data$compactness_mean - data$compactness_worst
data$symmetry_mwdiff <- data$symmetry_mean - data$symmetry_worst

```

## Model
```{r}
logit_mwdiff <- glm(diagnosis_num ~ radius_mwdiff + 
                     texture_mwdiff + smoothness_mwdiff
                   + compactness_mwdiff + symmetry_mwdiff,
                 data = data,
                 family = binomial)
tidy(logit_mwdiff)
```


```{r}

## RAW WITHOUT TEST TRAIN SPLIT
# predicted probability of M
data$pred_prob_mwdiff <- predict(logit_mwdiff, type = "response")

# predicted class using 0.5 threshold
data$pred_class_mwdiff <- ifelse(data$pred_prob_mwdiff > 0.5, "M", "B")
data$pred_class_mwdiff <- factor(data$pred_class_mwdiff, levels = c("B", "M"))

# confusion matrix
table(Predicted = data$pred_class_mwdiff, Actual = data$diagnosis)


```



```{r}
## ADDING TEST TRAIN SPLIT

set.seed(325)

train_idx <- sample(1:nrow(data), 0.7 * nrow(data))
train <- data[train_idx, ]
test  <- data[-train_idx, ]

train_acc <- mean(train$pred_class_mwdiff == train$diagnosis_num)
test_acc  <- mean(test$pred_class_mwdiff == test$diagnosis_num)

train_acc
test_acc


```
IDK what's going on here I'm ngl

```{r}

auc_train <- roc(train$diagnosis_num, train$pred_prob_mwdiff)$auc
auc_test  <- roc(test$diagnosis_num, test$pred_prob_mwdiff)$auc

auc_train
auc_test

roc_obj_mwdiff <- roc(test$diagnosis_num, test$pred_prob_mwdiff)

ggroc(roc_obj_mwdiff, size = 1.1, color = "blue") +
  ggtitle(paste("ROC Curve (AUC =", round(roc_obj_mwdiff$auc, 3), ")")) +
  theme_minimal(base_size = 14)

```
The difference seems to have the lowest ROC which is interesting...


## Me trying to make the 3d tumor
```{r}
library(scatterplot3d)

# Pick three predictors
x <- data$radius_mean
y <- data$texture_mean
z <- data$compactness_mean

# Color by diagnosis
colors <- ifelse(data$diagnosis == "M", "red", "blue")

scatterplot3d(x, y, z,
              color = colors,
              pch = 16,
              xlab = "Radius Mean",
              ylab = "Texture Mean",
              zlab = "Compactness Mean",
              main = "3D Visualization of Tumors")
legend("topright", legend = c("Benign", "Malignant"),
       col = c("blue", "red"), pch = 16)

```

```{r}
library(plotly)

# --- 1. Select tumor from data ---
tumor_index <- 1  # choose which tumor
tumor_radius <- data$radius_mean[tumor_index] / 10  # scale down for viz
prob <- predict(logit_means, newdata = data[tumor_index, ], type = "response")

# --- 2. Create a simplified female torso silhouette as an ellipsoid ---
# We'll use two parts: torso (ellipsoid) + breast hemisphere

# Torso ellipsoid
u <- seq(0, 2*pi, length.out = 50)
v <- seq(0, pi, length.out = 50)
xt <- outer(cos(u), sin(v)) * 4     # x-radius ~4
yt <- outer(sin(u), sin(v)) * 2.5   # y-radius ~2.5 (depth)
zt <- outer(rep(1, length(u)), cos(v)) * 8  # height ~8

# Breast hemisphere (one side)
theta <- seq(0, 2*pi, length.out = 50)
phi <- seq(0, pi/2, length.out = 50)  # half sphere
xb <- outer(cos(theta), sin(phi)) * 2 + 2  # shift right for breast
yb <- outer(sin(theta), sin(phi)) * 2
zb <- outer(rep(1, length(theta)), cos(phi)) * 2 + 6  # attach on upper torso

# --- 3. Create tumor sphere ---
ttheta <- seq(0, 2*pi, length.out = 30)
tphi <- seq(0, pi, length.out = 30)
xs <- tumor_radius * outer(sin(tphi), cos(ttheta)) + (2 + tumor_radius * 0.2)
ys <- tumor_radius * outer(sin(tphi), sin(ttheta)) + 0
zs <- tumor_radius * outer(cos(tphi), rep(1, length(ttheta))) + 6

# --- 4. Plot with plotly ---
plot_ly() %>%
  # Torso surface
  add_surface(
    x = ~xt, y = ~yt, z = ~zt,
    surfacecolor = matrix(1, nrow = length(u), ncol = length(v)),
    colorscale = list(c(0, 1), c("lightpink", "lightpink")),
    opacity = 0.6,
    showscale = FALSE
  ) %>%
  # Breast hemisphere
  add_surface(
    x = ~xb, y = ~yb, z = ~zb,
    surfacecolor = matrix(1, nrow = length(theta), ncol = length(phi)),
    colorscale = list(c(0, 1), c("lightpink", "lightpink")),
    opacity = 0.8,
    showscale = FALSE
  ) %>%
  # Tumor sphere
  add_surface(
    x = ~xs, y = ~ys, z = ~zs,
    surfacecolor = matrix(prob, nrow = length(tphi), ncol = length(ttheta)),
    colorscale = list(c(0, 1), c("blue", "red")),
    showscale = TRUE
  ) %>%
  layout(
    title = paste0("Breast Cancer Tumor Visualization\n(Malignancy Prob = ", round(prob, 3), ")"),
    scene = list(
      xaxis = list(title = "X"),
      yaxis = list(title = "Y"),
      zaxis = list(title = "Z"),
      camera = list(eye = list(x = 1.5, y = 1.5, z = 1.2))
    )
  )

```

```{r}
library(plotly)

# -----------------------------
# 1. Tumor data
# -----------------------------
tumor_index <- 1
tumor_radius_mm <- data$radius_mean[tumor_index] * 10  # assume radius_mean in cm, convert to mm
pred_prob <- predict(logit_means, newdata = data[tumor_index, ], type = "response")

# Average adult breast radius in mm
avg_breast_radius <- 120

# Scale tumor relative to average breast
tumor_radius_scaled <- tumor_radius_mm / avg_breast_radius * 5  # scale factor for visualization

# -----------------------------
# 2. Create breast hemisphere
# -----------------------------
theta <- seq(0, 2*pi, length.out = 50)
phi <- seq(0, pi/2, length.out = 50)
x_b <- outer(cos(theta), sin(phi)) * 5
y_b <- outer(sin(theta), sin(phi)) * 5
z_b <- outer(rep(1, length(theta)), cos(phi)) * 5

# -----------------------------
# 3. Create tumor sphere on top of breast
# -----------------------------
ttheta <- seq(0, 2*pi, length.out = 30)
tphi <- seq(0, pi, length.out = 30)
x_t <- tumor_radius_scaled * outer(sin(tphi), cos(ttheta)) + 0  # center x
y_t <- tumor_radius_scaled * outer(sin(tphi), sin(ttheta)) + 0  # center y
z_t <- tumor_radius_scaled * outer(cos(tphi), rep(1,length(ttheta))) + 3  # slightly above breast

# -----------------------------
# 4. Plot
# -----------------------------
plot_ly() %>%
  # Breast hemisphere
  add_surface(x = ~x_b, y = ~y_b, z = ~z_b,
              surfacecolor = matrix(1, nrow=50, ncol=50),
              colorscale = list(c(0,1), c("pink","pink")),
              opacity = 0.6,
              showscale = FALSE) %>%
  # Tumor sphere
  add_surface(x = ~x_t, y = ~y_t, z = ~z_t,
              surfacecolor = matrix(pred_prob, nrow=30, ncol=30),
              colorscale = list(c(0,1), c("blue","red")),
              showscale = TRUE) %>%
  layout(title = paste0(
    "Tumor relative to average woman breast\nPredicted Prob = ", 
    round(pred_prob,3)),
         scene = list(xaxis=list(title="X"),
                      yaxis=list(title="Y"),
                      zaxis=list(title="Z"),
                      camera=list(eye=list(x=1.5,y=1.5,z=1.2))))

```



